#!/usr/bin/env python
from __future__ import print_function
# -*- coding: latin1 -*-
from cups import modelSort

__author__ = 'Herbert OLiveira Rocha'


import sys
import commands
import re


from modules.utils import ReaderCsvOutput
from modules.annotations import annot_extractor
from modules.annotations import annot_grammar


class ReadJavaFile(object):
    """
    This class read the analyzed java program and then write a new instance of the program
    according to a framework model (e.g., TestNG or JCUTE) definied by the user.
    """


    def __init__(self):
        self.file_actual_number_line  = 0
        self.listOfCsvDataInput = {}


    def readFile(self, _javaPathFile):
        """
        Read and print the java file

        :param _javaPathFile: java file path
        :type _javaPathFile: str
        """

        javafile = open(_javaPathFile)
        linesjavafile = javafile.readlines()
        javafile.close()

        for index, line in enumerate(linesjavafile):
            self.file_actual_number_line = index
            print("%s - %s" % (self.file_actual_number_line,line), end="")


    def checkClaimsFileEgual(self, _beforefilepre, _afterfilepre):
        """
        This method performs a trigger in the method to identify if the properties
        generated by ESC/JAVA in the program after and before the preprocessing file are
        the same.

        :param _beforefilepre: java file path before preprocessing
        :type _beforefilepre: str
        :param _afterfilepre: java file path after preprocessing
        :type _afterfilepre: str
        :return: True if is egual and False otherwise
        """

        numlinesbefore = 0
        numlinesafter = 0
        with open(_beforefilepre) as f:
            total = sum(1 for _ in f)

        numlinesbefore = total

        with open(_afterfilepre) as f:
            total = sum(1 for _ in f)

        numlinesafter = total

        if numlinesbefore == numlinesafter:
            return True
        else:
            return False


    def instrumentCodeAssert(self, _javaPathFile, _claimsbeforeprecode, _csvPathFileToInst, _modelUnitTest, _datafileinput):
        """
        Intrument the new instance of the analyzed program with asserts with the properties according to model
        (e.g., TestNG or JCUTE) defined by the user.

        :param _javaPathFile: the path of the preprocessed java file
        :type _javaPathFile: str
        :param _claimsbeforeprecode: the list of the properties gathered before the preprocessing code
        :type _claimsbeforeprecode: str
        :param _csvPathFileToInst: the list of the properties already translated to JFORTES format
        :type _csvPathFileToInst: str
        :param _modelUnitTest: the model to be applied in the program to test. Now supporting: TestNG, JCUTE,
                               and java asserts.
        :type _modelUnitTest: str
        :param _datafileinput: data collected (e.g., inputs for methods) from analyzed java program
        :type _datafileinput: str
        :return: A list with the new instace of the program with the model to be tested in list_new_program_inst
        """

        modelToApply = self.getModelUnitTest(_modelUnitTest)
        #print(">>>", modelToApply)

        # Check what model to test should be applied in the analyzed program
        if modelToApply == "testng":
            # verifiyng if there are differences of the claims file
            numclaimsegual = self.checkClaimsFileEgual(_claimsbeforeprecode, _csvPathFileToInst)
            if numclaimsegual:
                # with the line number
                # Write msg with the line number in the assertions
                list_new_program_inst = self.applyTestNgModel(_javaPathFile, _claimsbeforeprecode, _csvPathFileToInst)
                return list_new_program_inst
            else:
                list_new_program_inst = self.applyTestNgModel(_javaPathFile, _claimsbeforeprecode, _csvPathFileToInst)
                return list_new_program_inst

        elif modelToApply == "jcute":
            #print (_datafileinput)
            # verifiyng if there are differences of the claims file
            numclaimsegual = self.checkClaimsFileEgual(_claimsbeforeprecode, _csvPathFileToInst)
            if numclaimsegual:
                # with the line number
                # Write msg with the line number in the assertions
                list_new_program_inst = self.apply_jcute_model(_javaPathFile, _claimsbeforeprecode, _csvPathFileToInst, _datafileinput)
                return list_new_program_inst
            else:
                list_new_program_inst = self.apply_jcute_model(_javaPathFile, _claimsbeforeprecode, _csvPathFileToInst, _datafileinput)
                return list_new_program_inst

        elif modelToApply == "junit":
            list_new_program_inst = self.applyJunitModel(_javaPathFile, _csvPathFileToInst)
            return list_new_program_inst

        elif modelToApply == "NO":

            # verifiyng if there are differences of the claims file
            numclaimsegual = self.checkClaimsFileEgual(_claimsbeforeprecode, _csvPathFileToInst)

            #text of the new program
            list_program_asserts = []

            javafile = open(_javaPathFile)
            linesjavafile = javafile.readlines()
            javafile.close()

            #claims before preprocessing code
            readCsv = ReaderCsvOutput.ReaderCsv()
            readCsv.loadCsvFile(_csvPathFileToInst)
            listOfCsvFirstClColummns = readCsv.getCsvColummns()

            #claims after preprocessing code
            readCsv = ReaderCsvOutput.ReaderCsv()
            readCsv.loadCsvFile(_csvPathFileToInst)
            listOfCsvNewClColummns = readCsv.getCsvColummns()




            for index, line in enumerate(linesjavafile):
                self.file_actual_number_line = index
                for i, numLineCl in enumerate(listOfCsvNewClColummns['Number_of_line']):
                    # Identify the lines to be instrumented
                    numToCompare = int(numLineCl) - 1
                    if numToCompare == index:
                        # DEBUG print(">>>>>>>>",numLineCl)
                        # generating the new with the assertion based on the claim
                        #print("assert( %s );" % str(listOfCsvNewClColummns['New_claim'][i]))
                        if numclaimsegual:
                            # with the line number
                            #list_program_asserts.append("// Number line in the original code: "+str(listOfCsvFirstClColummns['Number_of_line'][i]))
                            list_program_asserts.append("assert "+str(listOfCsvNewClColummns['New_claim'][i])+" : "+\
                                                        " \" \\n IN ORIGINAL CODE AT LINE: < "+str(listOfCsvFirstClColummns['Number_of_line'][i])+"> " +\
                                                    "\\n COMMENT: "+str(listOfCsvFirstClColummns['Comment'][i])+"\\n \";")
                        else:
                            list_program_asserts.append("assert( "+str(listOfCsvNewClColummns['New_claim'][i])+" );")

                #print(line, end="")
                list_program_asserts.append(str(line).rstrip())

            return list_program_asserts


    def getModelUnitTest(self, _dicModelTest):
        """
        Get the model to be applied in the analyzed program to execute the test cases generated by JFORTES.

        :param _dicModelTest: A dictionary with the model supported by JFORTES
        :return: the key of the dictionary
        """
        for key, value in _dicModelTest.items():
            if value:
                return key



    def applyTestNgModel(self,_javaPathFile, _claimsbeforeprecode, _csvPathFileToInst):
        """
        Apply the the model to TestNG framework to execute the test cases generated by JFORTES.

        :param _javaPathFile: the path of the java file
        :type _javaPathFile: str
        :param _claimsbeforeprecode: the path of the properties collected before the preprocessing
        :type _claimsbeforeprecode: str
        :param _csvPathFileToInst: the list of the properties already translated to JFORTES format
        :type _csvPathFileToInst: str
        :return: A list with the new instance of the analyzed program in the model of the TestNG framework
        """

        #TODO: Identify the pre-requirements to run test with TESTNG, e.g., the class needs to be public (public class Bag(){)
        #TODO: Add an option in jfortes to generate XML to run the tests

        #text of the new program
        list_program_asserts = []

        # Reading java file
        javafile = open(_javaPathFile)
        linesjavafile = javafile.readlines()
        javafile.close()

        #claims before preprocessing code
        readCsv = ReaderCsvOutput.ReaderCsv()
        readCsv.loadCsvFile(_csvPathFileToInst)
        listOfCsvFirstClColummns = readCsv.getCsvColummns()

        # Reading CSV file with the claims translated
        readCsv = ReaderCsvOutput.ReaderCsv()
        readCsv.loadCsvFile(_csvPathFileToInst)
        listOfCsvNewClColummns = readCsv.getCsvColummns()

        #claims after preprocessing code
        # Getting the number lines of the methods from the analyzed program
        listnumstartmethod = self.identifyNumLineOfMethods(_javaPathFile)

        # verifiyng if there are differences of the claims file
        numclaimsegual = self.checkClaimsFileEgual(_claimsbeforeprecode, _csvPathFileToInst)


        # Adding imports of the TestNG
        # TODO: BUG in the preprocessing code. It was added a blank space in the Assert import
        list_program_asserts.append("import org.testng.Assert; // <- [JFORTES]")
        list_program_asserts.append("import org.testng.annotations.Test; // <- [JFORTES]")
        list_program_asserts.append("")


        for index, line in enumerate(linesjavafile):
            self.file_actual_number_line = index

            # Checking if is a method header, i.e., start point
            if (index+1) in listnumstartmethod:
                list_program_asserts.append("@Test")


            for i, numLineCl in enumerate(listOfCsvNewClColummns['Number_of_line']):
                # Identify the lines to be instrumented
                numToCompare = int(numLineCl) - 1
                if numToCompare == index:
                    # DEBUG print(">>>>>>>>",numLineCl)
                    if numclaimsegual:
                        # generating the new with the assertion based on the claim
                        list_program_asserts.append("Assert.assertTrue( "+str(listOfCsvNewClColummns['New_claim'][i])+\
                                                    ", \" \\n IN ORIGINAL CODE AT LINE: < "+str(listOfCsvFirstClColummns['Number_of_line'][i])+"> " +\
                                                    "\\n COMMENT: "+str(listOfCsvFirstClColummns['Comment'][i])+"\\n \" );")
                    else:
                        # generating the new with the assertion based on the claim
                        list_program_asserts.append("Assert.assertTrue( "+str(listOfCsvNewClColummns['New_claim'][i])+" );")

            #print(line, end="")
            list_program_asserts.append(str(line).rstrip())

        return list_program_asserts


    def apply_jcute_model(self,_javaPathFile, _claimsbeforeprecode, _csvPathFileToInst, _datafileinput):
        """
        Apply the the model to JCUTE framework to execute the test cases generated by JFORTES.

        :param _javaPathFile: the path of the java file
        :type _javaPathFile: str
        :param _claimsbeforeprecode: the path of the properties collected before the preprocessing
        :type _claimsbeforeprecode: str
        :param _csvPathFileToInst: the list of the properties already translated to JFORTES format
        :type _csvPathFileToInst: str
        :param _datafileinput: data collected (e.g., inputs for methods) from analyzed java program
        :type _datafileinput: str
        :return: A list with the new instance of the analyzed program in the model of the JCUTE framework
        """

        #Identify if the program has main
        hasmain = self.has_main_method(_javaPathFile)

        #text of the new program
        list_program_asserts = []

        # Reading java file
        javafile = open(_javaPathFile)
        linesjavafile = javafile.readlines()
        javafile.close()

        #claims before preprocessing code
        readCsv = ReaderCsvOutput.ReaderCsv()
        readCsv.loadCsvFile(_csvPathFileToInst)
        listOfCsvFirstClColummns = readCsv.getCsvColummns()

        # Reading CSV file with the claims translated
        readCsv = ReaderCsvOutput.ReaderCsv()
        readCsv.loadCsvFile(_csvPathFileToInst)
        listOfCsvNewClColummns = readCsv.getCsvColummns()

        #claims after preprocessing code
        # Getting the number lines of the methods from the analyzed program
        listnumstartmethod = self.identifyNumLineOfMethods(_javaPathFile)

        # verifiyng if there are differences of the claims file
        numclaimsegual = self.checkClaimsFileEgual(_claimsbeforeprecode, _csvPathFileToInst)


        # Adding imports of the jcute
        # TODO: BUG in the preprocessing code. It was added a blank space in the Assert import
        list_program_asserts.append("import cute.Cute; // <- [JFORTES]")
        list_program_asserts.append("")

        lenoffile = len(linesjavafile)

        for index, line in enumerate(linesjavafile):

            self.file_actual_number_line = index

            for i, numLineCl in enumerate(listOfCsvNewClColummns['Number_of_line']):
                # Identify the lines to be instrumented

                numToCompare = int(numLineCl) - 1
                #print(numToCompare+" = "+index)
                if numToCompare == index:
                    list_program_asserts.append("// IN ORIGINAL CODE AT LINE: < "+str(listOfCsvFirstClColummns['Number_of_line'][i])+" > ")
                    list_program_asserts.append("// COMMENT: "+str(listOfCsvFirstClColummns['Comment'][i]))
                    list_program_asserts.append("Cute.Assert( " + str(listOfCsvNewClColummns['New_claim'][i]) + "); ")


            if lenoffile == (index+1):
                # Write a generic main to test the method
                if not hasmain:

                    # Identifying and gathering the jfortes annotation to generate main,
                    # if has no annotation the generic main to test the method IS NOT generated
                    getannot = annot_extractor.AnnotExtractor()
                    list_annots = getannot.gather_annot(_javaPathFile)


                    if len(list_annots) == 1:
                        # Stop the generic main generation
                        list_program_asserts.append("}")
                        return list_program_asserts

                    result_parse_annot = annot_grammar.main_grammar(list_annots)

                    # Reading CSV file with the data from code jfortes annotations
                    readCsvAnnot = ReaderCsvOutput.ReaderCsv()
                    readCsvAnnot.loadCsvFile(result_parse_annot)
                    listOfCsvDataAnnot = readCsvAnnot.getCsvColummns()
                    #print(listOfCsvDataAnnot)


                    #Adding a new main based on data gathered form parser
                    #print(_datafileinput)
                    list_program_asserts.append("public static void main(String[] args){")

                    # Reading CSV file with the data about program
                    readCsvi = ReaderCsvOutput.ReaderCsv()
                    readCsvi.loadCsvFile(_datafileinput)
                    self.listOfCsvDataInput = readCsvi.getCsvColummns()
                    #print(self.listOfCsvDataInput)

                    #Creating instance of the class
                    list_not_gen = []
                    #listclasses = self.list_all_class(_javaPathFile)
                    #if not len(listclasses) == 0
                    # Identify the contructor method
                    flag_has_constructor = False

                    #[--> generating each constructors]
                    list2visited_constructor = []
                    list2visited_method = []
                    count2codegen = -1
                    list_last_sequence_constr = []

                    for ai, annot_name in enumerate(listOfCsvDataAnnot['annot_name']):

                        if annot_name == "jfortes_constructor":
                            count2codegen += 1
                            ID = listOfCsvDataAnnot['attrSequence'][ai]

                            # TODO: add the correct sequence of the methods adopting list_last_sequence_constr


                            #print("Constructor: "+ listOfCsvDataAnnot['attrID'][ai])

                            actual_linenum_constr = ''
                            cont_di = 0
                            flag_mt = False
                            tmp_list_save_index_di = []
                            for i, item in enumerate(self.listOfCsvDataInput['Scope']):

                                #print(item +"=="+ listOfCsvDataAnnot['atrrName'][ai])
                                # first time
                                if cont_di == 0 and item == listOfCsvDataAnnot['attrName'][ai]:
                                    cont_di += 1
                                    #print("ft")
                                    if not i in list2visited_constructor:
                                        list2visited_constructor.append(i)
                                        actual_linenum_constr = self.listOfCsvDataInput['Line'][i]
                                        #print(self.listOfCsvDataInput['Variable'][i])
                                        tmp_list_save_index_di.append(i)

                                # Multiples args
                                if cont_di > 0 and item == listOfCsvDataAnnot['attrName'][ai]:
                                    #print(listOfCsvDataAnnot['atrrName'][ai])
                                    if actual_linenum_constr == self.listOfCsvDataInput['Line'][i]:
                                        #print("mt")
                                        flag_mt = True
                                        if not i in list2visited_constructor:
                                            list2visited_constructor.append(i)
                                            actual_linenum_constr = self.listOfCsvDataInput['Line'][i]
                                            #print(self.listOfCsvDataInput['Variable'][i])
                                            tmp_list_save_index_di.append(i)

                                # first time to new line constructor, i.e., is a second constructor
                                if cont_di > 0 and item == listOfCsvDataAnnot['attrName'][ai] and \
                                   not flag_mt:
                                    #print("lt")
                                    if not i in list2visited_constructor:
                                        list2visited_constructor.append(i)
                                        actual_linenum_constr = self.listOfCsvDataInput['Line'][i]
                                        #print(self.listOfCsvDataInput['Variable'][i])
                                        tmp_list_save_index_di.append(i)


                            # Generating code to constructor

                            # >> identify if is only ONE arg
                            if len(tmp_list_save_index_di) == 1:
                                # Identify is the constructor has input arg
                                # >> with NO args
                                if self.listOfCsvDataInput['Variable'][0] == "0NONE":
                                    list_program_asserts.append( listOfCsvDataAnnot['attrName'][ai] +
                                                                 " runJFORTES_" + num_contr + " = new " +
                                                                 listOfCsvDataAnnot['attrName'][ai]+"( );")
                                # >> with arg
                                else:

                                    # has array in input?
                                    analysisInput = self.is_list_input(self.listOfCsvDataInput['Type'][0])

                                    if analysisInput[0]:
                                        tmpvararray = ''
                                        tmpvararray = self.generateArrayInt(analysisInput[2], analysisInput[1])
                                        list_program_asserts.append(tmpvararray[0])
                                        list_program_asserts.append(
                                            listOfCsvDataAnnot['attrName'][ai] + " runJFORTES_" + str(count2codegen) + " = new " +
                                            listOfCsvDataAnnot['attrName'][ai] + "( " + tmpvararray[1] + " );")
                                    else:
                                        if self.listOfCsvDataInput['Type'][value] == "0NONE":
                                            list_program_asserts.append(
                                                listOfCsvDataAnnot['attrName'][ai] + " runJFORTES_" + str(count2codegen) + " = new " +
                                                listOfCsvDataAnnot['attrName'][ai] + "( );")

                                        elif self.listOfCsvDataInput['Type'][value] == "String":
                                            list_program_asserts.append(
                                                listOfCsvDataAnnot['attrName'][ai] + " runJFORTES_" + str(count2codegen) + " = new " +
                                                listOfCsvDataAnnot['attrName'][ai] + "( Cute.input.String(\".\") );")

                                        elif self.listOfCsvDataInput['Type'][value] == "int" or self.listOfCsvDataInput['Type'][0] == "Integer":
                                            list_program_asserts.append(
                                                listOfCsvDataAnnot['attrName'][ai] + " runJFORTES_" + str(count2codegen) + " = new " +
                                                listOfCsvDataAnnot['attrName'][ai] + "( Cute.input.Integer(\".\") );")

                                        elif self.listOfCsvDataInput['Type'][value] == "Float":
                                            list_program_asserts.append(
                                                listOfCsvDataAnnot['attrName'][ai] + " runJFORTES_" + str(count2codegen) + " = new " +
                                                listOfCsvDataAnnot['attrName'][ai] + "( Cute.input.Float(\".\") );")


                            # >> WITH multiples args
                            else:

                                pre_code = listOfCsvDataAnnot['attrName'][ai] + " runJFORTES_" + str(count2codegen) + \
                                           " = new " + listOfCsvDataAnnot['attrName'][ai] + "( "

                                midle_code = ''
                                tmp_vars = []
                                for num_contr, value in enumerate(tmp_list_save_index_di):

                                    # has array in input?
                                    analysisInput = self.is_list_input(self.listOfCsvDataInput['Type'][value])

                                    if analysisInput[0]:
                                        tmpvararray = ''
                                        tmpvararray = self.generateArrayInt(analysisInput[2], analysisInput[1])
                                        tmp_vars.append(tmpvararray[0])
                                        #list_program_asserts.append(tmpvararray[0])
                                        #list_program_asserts.append(
                                        #    listOfCsvDataAnnot['atrrName'][ai] + " runJFORTES_" + str(count2codegen) + " = new " +
                                        #    listOfCsvDataAnnot['atrrName'][ai] + "( " + tmpvararray[1] + " );")
                                        midle_code += tmpvararray[1]
                                        if (num_contr+1) < len(tmp_list_save_index_di):
                                            midle_code += ", "

                                    elif self.listOfCsvDataInput['Type'][value] == "String":
                                        #print("Cute.input.String(\".\")", end="")
                                        midle_code += "Cute.input.String(\".\")"
                                        if (num_contr+1) < len(tmp_list_save_index_di):
                                            #print(", ", end="")
                                            midle_code += ", "

                                    elif self.listOfCsvDataInput['Type'][value] == "int" or self.listOfCsvDataInput['Type'][value] == "Integer":
                                        #print("Cute.input.Integer(\".\")", end="")
                                        midle_code += "Cute.input.Integer(\".\")"
                                        if (num_contr+1) < len(tmp_list_save_index_di):
                                            #print(", ", end="")
                                            midle_code += ", "

                                    elif self.listOfCsvDataInput['Type'][value] == "Float":
                                        #print("Cute.input.Float(\".\")", end="")
                                        midle_code += "Cute.input.Float(\".\")"
                                        if (num_contr+1) < len(tmp_list_save_index_di):
                                            #print(", ", end="")
                                            midle_code += ", "

                                end_code = " );"

                                if len(tmp_vars) > 0:
                                    for vars in tmp_vars:
                                        list_program_asserts.append(vars)
                                    list_program_asserts.append(pre_code + midle_code + end_code)
                                else:
                                    list_program_asserts.append(pre_code + midle_code + end_code)


                            #Generating code to attributes
                            i2 = 0
                            for name in listOfCsvDataAnnot['annot_name']:
                                if name == "jfortes_attribute":

                                    if listOfCsvDataAnnot['attrFromConstructors'][i2] == ID:

                                        if self.listOfCsvDataInput['Type'][i2] == "String":
                                            list_program_asserts.append(" runJFORTES_" + str(count2codegen)+"." + listOfCsvDataAnnot['attrName'][i2] + " = Cute.input.String();")
                                        elif self.listOfCsvDataInput['Type'][i2] == "int" or self.listOfCsvDataInput['Type'][i2] == "Integer":
                                            list_program_asserts.append(" runJFORTES_" +str(count2codegen)+"." +listOfCsvDataAnnot['attrName'][i2] + "= Cute.input.Integer();")
                                        elif self.listOfCsvDataInput['Type'][i2] == "float":
                                            list_program_asserts.append(" runJFORTES_" + str(count2codegen)+"." + listOfCsvDataAnnot['attrName'][i2] + " = Cute.input.String();")
                                        #array 1 dimension
                                        elif self.listOfCsvDataInput['Type'][i2] == "int[]":
                                           list_program_asserts.append(" runJFORTES_" +str(count2codegen)+"." +listOfCsvDataAnnot['attrName'][i2] + "= new int [Cute.input.Integer()];")
                                        elif self.listOfCsvDataInput['Type'][i2] == "float[]":
                                           list_program_asserts.append(" runJFORTES_" +str(count2codegen)+"." +listOfCsvDataAnnot['attrName'][i2] + "= new Float [Cute.input.Float()];")
                                        elif (self.listOfCsvDataInput['Type'][i2] == "Object[]"):
                                             list_program_asserts.append(" runJFORTES_" +str(count2codegen)+"." +listOfCsvDataAnnot['attrName'][i2] + "=new Object [Cute.input.Object(\".\")];")
                                        elif (self.listOfCsvDataInput['Type'][i2] == "String[]"):
                                             list_program_asserts.append(" runJFORTES_" +str(count2codegen)+"." +listOfCsvDataAnnot['attrName'][i2] + "=new String [Cute.input.String(\".\")];")

                                        #array 2 dimensions
                                        elif self.listOfCsvDataInput['Type'][i2] == "int[][]":
                                           list_program_asserts.append(" runJFORTES_" +str(count2codegen)+"." +listOfCsvDataAnnot['attrName'][i2] + "= new int [Cute.input.Integer()][Cute.input.Integer()];';")
                                        elif self.listOfCsvDataInput['Type'][i2] == "float[][]":
                                           list_program_asserts.append(" runJFORTES_" +str(count2codegen)+"." +listOfCsvDataAnnot['attrName'][i2] + "= new Float [Cute.input.Float()][Cute.input.Float()];")
                                        elif (self.listOfCsvDataInput['Type'][i2] == "Object[][]"):
                                             list_program_asserts.append(" runJFORTES_" +str(count2codegen)+"." +listOfCsvDataAnnot['attrName'][i2] + "=new int [Cute.input.Object()][Cute.input.Object()];")
                                        elif (self.listOfCsvDataInput['Type'][i2] == "String[][]"):
                                             list_program_asserts.append(" runJFORTES_" +str(count2codegen)+"." +listOfCsvDataAnnot['attrName'][i2] + "=new int [Cute.input.String()][Cute.input.String()];")

                                #Generating code to methods

                                if name == "jfortes_method":

                                    for attrFromConstr in listOfCsvDataAnnot['attrFromConstructors']:
                                        if attrFromConstr == ID:

                                            actual_linenum_method = ''
                                            cont_di = 0
                                            flag_mt = False
                                            tmp_list_save_index_di = []
                                            for i, item in enumerate(self.listOfCsvDataInput['Scope']):

                                                #print(item +"=="+ listOfCsvDataAnnot['atrrName'][ai])
                                                # first time
                                                if cont_di == 0 and item == listOfCsvDataAnnot['attrName'][ai]:
                                                    cont_di += 1
                                                    #print("ft")
                                                    if not i in list2visited_method:
                                                        list2visited_method.append(i)
                                                        actual_linenum_method = self.listOfCsvDataInput['Line'][i]
                                                        #print(self.listOfCsvDataInput['Variable'][i])
                                                        tmp_list_save_index_di.append(i)

                                                # Multiples args
                                                if cont_di > 0 and item == listOfCsvDataAnnot['attrName'][ai]:
                                                    #print(listOfCsvDataAnnot['atrrName'][ai])
                                                    if actual_linenum_method == self.listOfCsvDataInput['Line'][i]:
                                                        #print("mt")
                                                        flag_mt = True
                                                        if not i in list2visited_method:
                                                            list2visited_method.append(i)
                                                            actual_linenum_method = self.listOfCsvDataInput['Line'][i]
                                                            #print(self.listOfCsvDataInput['Variable'][i])
                                                            tmp_list_save_index_di.append(i)

                                                # first time to new line constructor, i.e., is a second constructor
                                                if cont_di > 0 and item == listOfCsvDataAnnot['attrName'][ai] and \
                                                   not flag_mt:
                                                    #print("lt")
                                                    if not i in list2visited_method:
                                                        list2visited_method.append(i)
                                                        actual_linenum_method = self.listOfCsvDataInput['Line'][i]
                                                        #print(self.listOfCsvDataInput['Variable'][i])
                                                        tmp_list_save_index_di.append(i)

                                        if len(tmp_list_save_index_di) == 1:

                                            # Identify is the constructor has input arg
                                            # >> with NO args
                                            if self.listOfCsvDataInput['Variable'][0] == "0NONE":

                                                list_program_asserts.append( "runJFORTES_" + str(count2codegen) + "." + listOfCsvDataAnnot['attrName'][i2]+ "();")

                                            else:

                                                # has array in input?
                                                analysisInput = self.is_list_input(self.listOfCsvDataInput['Type'][0])

                                                if analysisInput[0]:

                                                    tmpvararray = ''
                                                    tmpvararray = self.generateArrayInt(analysisInput[2], analysisInput[1])
                                                    list_program_asserts.append(tmpvararray[0])
                                                    list_program_asserts.append(
                                                        "runJFORTES_" + str(count2codegen) + "." + listOfCsvDataAnnot['attrName'][i2]
                                                        + "( " + tmpvararray[1] + " );")
                                                else:

                                                    if self.listOfCsvDataInput['Type'][i2] == "0NONE":

                                                        list_program_asserts.append(
                                                            "runJFORTES_" + str(count2codegen) + "." + listOfCsvDataAnnot['attrName'][i2] + "( );")

                                                    elif self.listOfCsvDataInput['Type'][i2] == "String":

                                                        list_program_asserts.append(
                                                           "runJFORTES_" + str(count2codegen) + "." + listOfCsvDataAnnot['attrName'][i2] + "( Cute.input.String(\".\") );")

                                                    elif self.listOfCsvDataInput['Type'][i2] == "int" or self.listOfCsvDataInput['Type'][0] == "Integer":
                                                        list_program_asserts.append(
                                                           "runJFORTES_" + str(count2codegen) + "." + listOfCsvDataAnnot['attrName'][i2] + "( Cute.input.Integer(\".\") );")

                                                    elif self.listOfCsvDataInput['Type'][i2] == "Float":
                                                        list_program_asserts.append(
                                                            "runJFORTES_" + str(count2codegen) + "." + listOfCsvDataAnnot['attrName'][i2] + "( Cute.input.Float(\".\") );")



                                i2 +=1



                    #         if self.listOfCsvDataInput['Scope'][i] in listclasses:
                    #             flag_has_constructor = True
                    #             list_not_gen.append(i)
                    #             # has array in input?
                    #             analysisInput = self.is_list_input(self.listOfCsvDataInput['Type'][i])
                    #
                    #             if analysisInput[0]:
                    #                 tmpvararray = ''
                    #                 if analysisInput[1] == "int":
                    #                     tmpvararray = self.generateArrayInt(analysisInput[2])
                    #                 list_program_asserts.append(tmpvararray[0])
                    #                 list_program_asserts.append(
                    #                     self.listOfCsvDataInput['Scope'][i]+" runJFORTES = new "
                    #                     +self.listOfCsvDataInput['Scope'][i]+"( " + tmpvararray[1] + " );")
                    #             else:
                    #                 list_program_asserts.append(
                    #                     self.listOfCsvDataInput['Scope'][i]+" runJFORTES = new "
                    #                     +self.listOfCsvDataInput['Scope'][i]+"( );")
                    #
                    # if not flag_has_constructor:
                    #     for classname in listclasses:
                    #         list_program_asserts.append(
                    #                     classname+" runJFORTES = new "
                    #                             +classname+"( );")

                    # DOING: Adding the attributes
                    # for i, item in enumerate(self.listOfCsvDataInput['From']):
                    #     if item == "attribute":
                    #         # has array in input?
                    #         analysisInput = self.is_list_input(self.listOfCsvDataInput['Type'][i])
                    #         if analysisInput[0]:
                    #             # Why we do not have all types here???
                    #             genassignment = ''
                    #             if analysisInput[1] == "int":
                    #                 if analysisInput[2] == 1:
                    #                     genassignment = 'runJFORTES.'+self.listOfCsvDataInput['Variable'][i].strip()+' = new int [Cute.input.Integer()];'
                    #                     list_program_asserts.append(genassignment)
                    #             elif analysisInput[1] == "Object":
                    #                 if analysisInput[2] == 1:
                    #                     genassignment = 'runJFORTES.'+self.listOfCsvDataInput['Variable'][i].strip()+' = new Object [Cute.input.Object(".")];'
                    #                     list_program_asserts.append(genassignment)
                    #             elif analysisInput[1] == "String":
                    #                 if analysisInput[2] == 1:
                    #                     genassignment = 'runJFORTES.'+self.listOfCsvDataInput['Variable'][i].strip()+' = new String [Cute.input.String(".")];'
                    #                     list_program_asserts.append(genassignment)
                    #         else:
                    #
                    #             if self.listOfCsvDataInput['Type'][i] == 'int':
                    #                 genassignment = 'runJFORTES.'+self.listOfCsvDataInput['Variable'][i].strip()+' = Cute.input.Integer();'
                    #                 list_program_asserts.append(genassignment)
                    #             elif self.listOfCsvDataInput['Type'][i] == 'String':
                    #                 genassignment = 'runJFORTES.'+self.listOfCsvDataInput['Variable'][i].strip()+' = Cute.input.String();'
                    #                 list_program_asserts.append(genassignment)
                    #             elif self.listOfCsvDataInput['Type'][i] == 'float':
                    #                 genassignment = 'runJFORTES.'+self.listOfCsvDataInput['Variable'][i].strip()+' = Cute.input.Float();'
                    #                 list_program_asserts.append(genassignment)
                    #
                    #             #sys.exit()
                    #             #
                    # # DOING: Adding the methods
                    # i = 0
                    # while i < len(self.listOfCsvDataInput['From']):
                    # #for i, item in enumerate(self.listOfCsvDataInput['From']):
                    #     if self.listOfCsvDataInput['From'][i] == "method" and not i in list_not_gen:
                    #         # With parameters
                    #         if not self.listOfCsvDataInput['Type'][i] == "0NONE":
                    #             #print("Generate parameters")
                    #             # has array in input?
                    #             analysisInput = self.is_list_input(self.listOfCsvDataInput['Type'][i])
                    #             if not analysisInput[0]:
                    #                 # Possible method with multiples inputs
                    #                 if (i+1) < len(self.listOfCsvDataInput['From']):
                    #                     flag_walk = True
                    #                     init_method = 'runJFORTES.'+self.listOfCsvDataInput['Scope'][i].strip()+'('
                    #                     list_args_input = []
                    #                     while i+1 < len(self.listOfCsvDataInput['From']) and flag_walk:
                    #                         if self.listOfCsvDataInput['Line'][i] == self.listOfCsvDataInput['Line'][i+1]:
                    #
                    #                             #list_args_input.append('TODO')
                    #                             # TODO: Replace by a function
                    #                             # has array in input?
                    #                             analysisInput = self.is_list_input(self.listOfCsvDataInput['Type'][i])
                    #                             if analysisInput[0]:
                    #                                 genassignment = ''
                    #                                 if analysisInput[1] == "int":
                    #                                     if analysisInput[2] == 1:
                    #                                         list_args_input.append('int[] inM_JFORTES = new int [Cute.input.Integer()]')
                    #                                 elif analysisInput[1] == "Object":
                    #                                     if analysisInput[2] == 1:
                    #                                         list_args_input.append('Object[] inM_JFORTES = new Object [Cute.input.Object()]')
                    #
                    #                             else:
                    #                                 if self.listOfCsvDataInput['Type'][i] == 'int':
                    #                                     list_args_input.append('Cute.input.Integer()')
                    #                                 elif self.listOfCsvDataInput['Type'][i] == 'String':
                    #                                     list_args_input.append('Cute.input.String()')
                    #                                 elif self.listOfCsvDataInput['Type'][i] == 'float':
                    #                                     list_args_input.append('Cute.input.Float')
                    #                             i += 1
                    #                             if not i+1 < len(self.listOfCsvDataInput['From']):
                    #                                 flag_walk = False
                    #                             elif self.listOfCsvDataInput['Line'][i] == self.listOfCsvDataInput['Line'][i+1]:
                    #                                 #list_args_input.append('TODO')
                    #                                 # TODO: Replace by a function
                    #                                 # has array in input?
                    #                                 analysisInput = self.is_list_input(self.listOfCsvDataInput['Type'][i])
                    #                                 if analysisInput[0]:
                    #                                     genassignment = ''
                    #                                     if analysisInput[1] == "int":
                    #                                         if analysisInput[2] == 1:
                    #                                             list_args_input.append('int[] inM_JFORTES = new int [Cute.input.Integer()]')
                    #                                     elif analysisInput[1] == "Object":
                    #                                         if analysisInput[2] == 1:
                    #                                             list_args_input.append('Object[] inM_JFORTES = new Object [Cute.input.Object()]')
                    #
                    #                                 else:
                    #                                     if self.listOfCsvDataInput['Type'][i] == 'int':
                    #                                         list_args_input.append('Cute.input.Integer()')
                    #                                     elif self.listOfCsvDataInput['Type'][i] == 'String':
                    #                                         list_args_input.append('Cute.input.String()')
                    #                                     elif self.listOfCsvDataInput['Type'][i] == 'float':
                    #                                         list_args_input.append('Cute.input.Float')
                    #                         else:
                    #                             flag_walk = False
                    #                     genassignment = ','.join(list_args_input)
                    #                     list_program_asserts.append(init_method+genassignment+');')
                    #                 # only one input arg
                    #                 else:
                    #                     # TODO: generate the args input
                    #                     genassignment = 'runJFORTES.'+self.listOfCsvDataInput['Scope'][i].strip()+'();'
                    #                     list_program_asserts.append(genassignment)
                    #
                    #             # TODO for arrays
                    #         else:
                    #             genassignment = 'runJFORTES.'+self.listOfCsvDataInput['Scope'][i].strip()+'();'
                    #             list_program_asserts.append(genassignment)
                    #
                    #     i += 1




                    list_program_asserts.append("}")



            list_program_asserts.append(str(line).rstrip())

        return list_program_asserts


    def is_list_input(self, _typetext):
        """
        Identify if a input to variable is a list

        :param _typetext: the text code with the assignment
        :return: a list (list_result) that has answer (True or False) and its dimension
        """
        list_result = [] # True|False, type , array dimension
        matchQuantifiers = re.search(r'(.*)([\[][ ]*[\]])+', _typetext)
        if matchQuantifiers:
            list_result.append(True)
            list_result.append(matchQuantifiers.group(1))
            dim = matchQuantifiers.group(2).split('[').count(']')
            list_result.append(dim)
        else:
            list_result.append(False)
        return list_result


    def generateArrayInt(self, _dimension, type):
        """
        Generate an array for JCUTE model using the method Cute.input.*

        :param _dimension: the length of the array to be generated
        :return: the text of the code with the array generated
        """
        codetxt = [] # new line, the var
        if type == 'int':
            # For 1
            if _dimension == 1:
                codetxt.append('int[] arrJFORTES = new int [Cute.input.Integer()]; ')
                codetxt.append('arrJFORTES')

            #For 2
            if _dimension == 2:
                codetxt.append('int[][] arrJFORTES = new int [Cute.input.Integer()][Cute.input.Integer()];')
                codetxt.append('arrJFORTES')

        if type == 'float':
            # For 1
            if _dimension == 1:
                codetxt.append('int[] arrJFORTES = new float [Cute.input.Float()]; ')
                codetxt.append('arrJFORTES')

            #For 2
            if _dimension == 2:
                codetxt.append('int[][] arrJFORTES = new float [Cute.input.Float()][Cute.input.Float()];')
                codetxt.append('arrJFORTES')

        if type == 'String':
            #For 1
            if _dimension == 1:
                codetxt.append('int[] arrJFORTES = new String [Cute.input.String()];')
                codetxt.append('arrJFORTES')

            #For 2
            if _dimension == 2:
                codetxt.append('int[][] arrJFORTES = new String [Cute.input.String()][Cute.input.String()];')
                codetxt.append('arrJFORTES')

        return codetxt




    def applyJunitModel(self,_javaPathFile, _csvPathFileToInst):
        """
        To appaly the JUNIT model, but is not supported yet :(

        :param _javaPathFile: the path of the java file
        :type _javaPathFile: str
        :param _csvPathFileToInst: the list of the properties already translated to JFORTES format
        :type _csvPathFileToInst: str
        :return: Error menssage
        """
        print("Sorry about that. This model is not support yet :( ")
        sys.exit()


    def identifyNumLineOfMethods(self,_javaPathFile):
        """
        Identify the lines where start (based on line numbers) the methods in the analyzed program.

        :param _javaPathFile: the path of the java file
        :type _javaPathFile: str
        :return: the list (listnumstartmethods) with the line numbers where is the begin of the methods
        """

        # list of the line number where a method is started
        listnumstartmethods = []

        # Gettting the name of the functions
        get_start_data_method = commands.getoutput("ctags --sort=NO -x --c-kinds=f "+_javaPathFile).split("\n")
        for line in get_start_data_method:
            #print(line)
            matchDataMethod = re.search(r'([a-zA-Z0-9\_\(\)\[\]]*)[ ]*([a-zA-Z0-9]*)[ ]*([0-9]*)', line)
            if matchDataMethod:
                if matchDataMethod.group(2) == "method":
                    #print(matchDataMethod.group(1))
                    #self.list_name_func.append(matchDataMethod.group(1))
                    #print(">>>>> "+matchDataMethod.group(3))
                    listnumstartmethods.append(int(matchDataMethod.group(3)))
                    #self.list_num_start_func.append(matchDataMethod.group(3))

        return listnumstartmethods


    def has_main_method(self,_javaPathFile):
        """
        Identify if the analyzed program has the main method

        :param _javaPathFile: _javaPathFile: the path of the java file
        :type _javaPathFile: str
        :return: True or False
        """
        # Gettting the name of the functions
        get_start_data_method = commands.getoutput("ctags --sort=NO -x --c-kinds=f "+_javaPathFile).split("\n")
        for line in get_start_data_method:
            #print(line)
            matchData = re.search(r'([a-zA-Z0-9\_\(\)\[\]]*)[ ]*([a-zA-Z0-9]*)[ ]*([0-9]*)', line)
            if matchData:
                #print(matchData.group(1)+" >> "+matchData.group(2))
                #sys.exit()
                if matchData.group(2) == "method":
                    if matchData.group(1) == "main":
                        return True
                    else:
                        return False


    def list_all_class(self, _javaPathFile):
        """
        Identify all classes in the analyzed program

        :param _javaPathFile: _javaPathFile: the path of the java file
        :type _javaPathFile: str
        :return: a list (resultlistclasses) of the line numbers where begin the classes identified
        """

        resultlistclasses = []
        # Gettting the name of the functions
        get_start_data_method = commands.getoutput("ctags --sort=NO -x --c-kinds=f "+_javaPathFile).split("\n")
        for line in get_start_data_method:
            #print(line)
            matchData = re.search(r'([a-zA-Z0-9\_\(\)\[\]]*)[ ]*([a-zA-Z0-9]*)[ ]*([0-9]*)', line)
            if matchData:
                if matchData.group(2) == "class":
                    resultlistclasses.append(matchData.group(1))

        return resultlistclasses




